# notes
## python 的引用
[python 引用和对象理解](https://www.cnblogs.com/ShaunChen/p/5656971.html)
### 1
```
>>> a = 3
>>> b = 3
>>> id(a)
10289448
>>> id(b)
10289448
```
在这里可以看到, 这俩个引用指向了同一个 对象，这是为什么呢? 这个跟python的内存机制有关系，因为对于语言来说，频繁的进行对象的销毁和建立，
特别浪费性能。所以在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。  
### 2
```
>>> a = 4
>>> b = a
>>> id(a)
36151568
>>> id(b)
36151568
```
可以看到 a 的引用改变了，但是 b 的引用未发生改变；a，b指向不同的对象； 第3句对 a 进行了重新赋值，让它指向了新的 对象6；
即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用指向一个新的引用，并不影响其他的引用的指向。
从效果上看，就是各个引用各自独立，互不影响。  
### 3 关于python中的 可变数据类型 和 不可变数据类型
```
>>> L1 = [1,2,3]
>>> L2 = L1
>>> id(L1)
139643051219496
>>> id(L2)
139643051219496
```
此时 L1 和 L2 的引用相同，都是指向 [1,2,3]这个列表对象。   
```
>>> L1[0] = 10
>>> id(L1)
139643051219496
>>> id(L2)
139643051219496
>>> L2
[10, 2, 3]
```
在本次实验中，L1 和 L2 的引用没有发生任何变化，但是 列表对象[1,2,3] 的值 变成了 [10,2,3]（列表对象改变了）  
在该情况下，我们不再对L1这一引用赋值，而是对L1所指向的表的元素赋值。结果是，L2也同时发生变化。  
原因何在呢？因为L1，L2的指向没有发生变化，依然指向那个表。表实际上是包含了多个引用的对象（每个引用是一个元素，比如L1[0]，L1[1]..., 
每个引用指向一个对象，比如1,2,3), 。而L1[0] = 10这一赋值操作，并不是改变L1的指向，而是对L1[0], 也就是表对象的一部份(一个元素)，进行操作，
所以所有指向该对象的引用都受到影响。  
（与之形成对比的是，我们之前的赋值操作都没有对对象自身发生作用，只是改变引用指向。）
列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)，词典也是这样的数据类型。  
而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)。  
我们之前学的元组(tuple)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是immutable object。  
### is关键字
当然，我们也可以要想知道是否指向同一个对象，我们可以使用 python的 is 关键词，is用于判断两个引用所指的对象是否相同。
```
>>> a = 4  ……id(a) = 36151568
>>> b =a   ……id(b) = 36151568
>>> a is b 
True
```
```
>>> a = a + 2  ……id(a) = 36151520
>>> a is b  ……id(b) = 36151568
False
```
